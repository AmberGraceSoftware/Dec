[{"title":"AngleSpring","type":0,"sectionRef":"#","url":"/api/AngleSpring","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#functions","content":" "},{"title":"ResetVelocity​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#ResetVelocity","content":"&lt;/&gt; AngleSpring:ResetVelocity() → () Sets the velocity of the spring to the zero (or the origin vector). Useful in conjunction with Spring:SetPosition  "},{"title":"CurrentTarget​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#CurrentTarget","content":"&lt;/&gt; AngleSpring:CurrentTarget() → () Gets the current value of the spring's target observable.  "},{"title":"SetPosition​","type":1,"pageTitle":"AngleSpring","url":"/api/AngleSpring#SetPosition","content":"&lt;/&gt; AngleSpring:SetPosition() → () Moves the current position of the spring to a new value, keeping the current velocity intact. "},{"title":"Alpha","type":0,"sectionRef":"#","url":"/api/Alpha","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Alpha","url":"/api/Alpha#functions","content":" "},{"title":"Slice​","type":1,"pageTitle":"Alpha","url":"/api/Alpha#Slice","content":"&lt;/&gt; Alpha:Slice( startAlpha: number, endAlpha: number ) → Alpha Creates a slice of the current Alpha Observable that starts at startAlpha (maps to 0) and ends at endAlpha (maps to 1). Useful for slicing up animation sequences into smaller slices.  "},{"title":"Curve​","type":1,"pageTitle":"Alpha","url":"/api/Alpha#Curve","content":"&lt;/&gt; Alpha:Curve( easingStyle: Enum.EasingStyle?, easingDirection: Enum.EasingDirection? ) → Alpha Creates a new Alpha Observable that interpolates between 0 and 1 using the given easing style and direction. Useful for creating non-linear animations.  "},{"title":"Invert​","type":1,"pageTitle":"Alpha","url":"/api/Alpha#Invert","content":"&lt;/&gt; Alpha:Invert() → Alpha Creates a new Alpha Observable that maps 0 to 1 and 1 to 0 from the original Observable. Useful for reversing animations, output values, etc.  "},{"title":"Lerp​","type":1,"pageTitle":"Alpha","url":"/api/Alpha#Lerp","content":"&lt;/&gt; Alpha:Lerp( startValue: T, goalValue: T ) → Observable&lt;T&gt;-ThelerpedObservable. Creates a new Observable that outputs an interpolated value between the start value and goal value based on the current Alpha value. "},{"title":"Dict","type":0,"sectionRef":"#","url":"/api/Dict","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Dict","url":"/api/Dict#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"Dict","url":"/api/Dict#Set","content":"&lt;/&gt; Dict:Set( key: K, value: V ) → () Sets the value at a specific key.  "},{"title":"Current​","type":1,"pageTitle":"Dict","url":"/api/Dict#Current","content":"&lt;/&gt; Dict:Current(key: K?) → V | {[K: V]} Gets the current value at a specific key, or the current value of the whole dictionary if no first argument is provided. caution Currently, the value returned by StateRecord:Current() with no first parameter is mutable! Modifying this value directly may cause unexpected behavior!  "},{"title":"Index​","type":1,"pageTitle":"Dict","url":"/api/Dict#Index","content":"&lt;/&gt; Dict:Index(key: K) → State&lt;V&gt; Creates a new observable which observes only a specific key within the dictionary. Changes in other keys will not affect subscribers to this indexed state. The returned observable is also a State object, and setting values in this state will set values in the original Dict object. "},{"title":"Eased","type":0,"sectionRef":"#","url":"/api/Eased","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Eased","url":"/api/Eased#functions","content":" "},{"title":"CurrentTarget​","type":1,"pageTitle":"Eased","url":"/api/Eased#CurrentTarget","content":"&lt;/&gt; Eased:CurrentTarget() → () Gets the current value of the eased object's target observable. "},{"title":"IntSpring","type":0,"sectionRef":"#","url":"/api/IntSpring","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#functions","content":" "},{"title":"ResetVelocity​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#ResetVelocity","content":"&lt;/&gt; IntSpring:ResetVelocity() → () Sets the velocity of the spring to the zero (or the origin vector). Useful in conjunction with Spring:SetPosition  "},{"title":"CurrentTarget​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#CurrentTarget","content":"&lt;/&gt; IntSpring:CurrentTarget() → () Gets the current value of the spring's target observable.  "},{"title":"SetPosition​","type":1,"pageTitle":"IntSpring","url":"/api/IntSpring#SetPosition","content":"&lt;/&gt; IntSpring:SetPosition() → () Moves the current position of the spring to a new value, keeping the current velocity intact. "},{"title":"Observable","type":0,"sectionRef":"#","url":"/api/Observable","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Observable","url":"/api/Observable#functions","content":" "},{"title":"Current​","type":1,"pageTitle":"Observable","url":"/api/Observable#Current","content":"&lt;/&gt; Observable:Current() → T Returns the current value of the Observable.  "},{"title":"Map​","type":1,"pageTitle":"Observable","url":"/api/Observable#Map","content":"&lt;/&gt; Observable:Map(mappingFunction: (value: T) → any) → Observable&lt;any&gt; Creates a new Observable that emits the values from the original Observable mapped by the provided function.  "},{"title":"Subscribe​","type":1,"pageTitle":"Observable","url":"/api/Observable#Subscribe","content":"&lt;/&gt; Observable:Subscribe( listener: (value: T) → (), immediatelyCallListener: boolean? ) → () → () Subscribes to changes in the Observable. Returns a function that, when called, will unsubscribe the listener from the Observable's changes. Iftrue is provided as a second argument, will also call the listener once immediately with the current value of the Observable. caution Make sure you handle the returned &quot;Unsubscribe&quot; function whenever a callingSubscribe! If you forget to do this, you may encounter memory leaks! Observables will remain in memory until all listeners are unsubscribed, and all VirtualInstances using it are unmounted -- A new Observable can always be garbage collected if dereferenced local coins = createCoinsObserver() -- However, once we subscribe to it, it will stick -- around in memory until we call Unsubscribe! local unsubscribe = coins:Subscribe(function(value) print(&quot;Coins is&quot;, value) end, true) task.wait(5) -- The &quot;coins&quot; observable can now be garbage collected unsubscribe()   "},{"title":"Destroy​","type":1,"pageTitle":"Observable","url":"/api/Observable#Destroy","content":"&lt;/&gt; Observable:Destroy() → () Destroys the Observable, releasing all its resources and unsubscribing all listeners. All further Observable:Subscribe calls will error. "},{"title":"Dec","type":0,"sectionRef":"#","url":"/api/Dec","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Dec","url":"/api/Dec#types","content":" "},{"title":"CanBeObservable<T>​","type":1,"pageTitle":"Dec","url":"/api/Dec#CanBeObservable<T>","content":"&lt;/&gt; type CanBeObservable&lt;T&gt; = Observable&lt;T&gt; | T Utility type that denotes a value can be an observable. Dec provides the utility function Dec.CoerceAsObservable for unwrapping these objects. "},{"title":"Properties​","type":1,"pageTitle":"Dec","url":"/api/Dec#properties","content":" "},{"title":"Nil​","type":1,"pageTitle":"Dec","url":"/api/Dec#Nil","content":"&lt;/&gt; Dec.Nil: Symbol&lt;&quot;Nil&quot;&gt; Symbol that represents a &quot;Nil&quot; value. Because &quot;nil&quot; values can't be represented as values of a Luau table, Dec.Nil can be used in its place. Example usage: return Dec.Premade(&quot;BillboardGui&quot;, { -- Sets the Adornee property of the premade UI to &quot;Nil&quot; on mount Adornee = Dec.Nil, })  "},{"title":"Functions​","type":1,"pageTitle":"Dec","url":"/api/Dec#functions","content":" "},{"title":"Root​","type":1,"pageTitle":"Dec","url":"/api/Dec#Root","content":"&lt;/&gt; Dec.Root(hostInstance: Instance ) → Root Creates a new Root instance. The Root is a reference to a real Roblox Instance and is used to reconcile Virtual Instances.  "},{"title":"ObserveFusionState​","type":1,"pageTitle":"Dec","url":"/api/Dec#ObserveFusionState","content":"&lt;/&gt; Dec.ObserveFusionState( Fusion: any, fusionStateObject: Fusion.StateObject&lt;T&gt; ) → Observable&lt;T&gt; Interoperability function that maps a Fusion StateObject to a Dec Observable object. The returned observable is garbage collected once dereferenced and unsubscribed/unmounted. The Fusion library must be provided, as Fusion StateObjects only work when embedded in a Fusion runtime.  "},{"title":"New​","type":1,"pageTitle":"Dec","url":"/api/Dec#New","content":"&lt;/&gt; Dec.New( className: string, props: {[string]: any}?, children: {[any]: CanBeObservable&lt;VirtualInstance?&gt;} ) → VirtualInstance Creates a new VirtualInstance that represents a newly-created Roblox Instance (via Instance.new(className)).  "},{"title":"Clone​","type":1,"pageTitle":"Dec","url":"/api/Dec#Clone","content":"&lt;/&gt; Dec.Clone( template: Instance , props: {[string]: any}?, children: {[any]: CanBeObservable&lt;VirtualInstance?&gt;} ) → VirtualInstance Creates a new VirtualInstance that represents a cloned Roblox Instance from a given template instance (via template:Clone()).  "},{"title":"Premade​","type":1,"pageTitle":"Dec","url":"/api/Dec#Premade","content":"&lt;/&gt; Dec.Premade( className: string, props: {[string]: any}?, children: {[any]: CanBeObservable&lt;VirtualInstance?&gt;} ) → VirtualInstance Creates a new VirtualInstance that represents a pre-existing Roblox Instance to be decorated. This will modify the properties of an existing instance rather than creating or destroying new instanvces. The instance modified will either be the one that is passed into Dec.Root(), or a child of an existing virtual instance that Dec will automatically wait for (specified viavirtualInstance:Child(path, Dec.Premade( . . . )) ).  "},{"title":"CoerceAsObservable​","type":1,"pageTitle":"Dec","url":"/api/Dec#CoerceAsObservable","content":"&lt;/&gt; Dec.CoerceAsObservable(value: CanBeObservable&lt;T&gt;) → Observable&lt;T&gt; This function coerces the passed in value to an Observable. Useful for unwrapped the CanBeObservable type in a component's props.  "},{"title":"Map​","type":1,"pageTitle":"Dec","url":"/api/Dec#Map","content":"&lt;/&gt; Dec.Map(...: Observable&lt;...T&gt;) → ((map: ...T) → ReturnType) → Observable&lt;ReturnType&gt; Returns a curryable mapping function, which in turn returns a derived observable from the dependent observables passed in. Example: local x = Dec.State(2) local y = Dec.State(3) local sum = Dec.Map(x, y)(function(currentX, currentY) return currentX + currentY end) print(sum:Current()) -- 5 For Observables where the values are a vector or scalar type, math operations can be used as an alias for Dec.Map! Example: local x = Dec.State(2) local y = Dec.State(3) local sum = x + y print(sum:Current()) -- 5   "},{"title":"IsVirtualInstance​","type":1,"pageTitle":"Dec","url":"/api/Dec#IsVirtualInstance","content":"&lt;/&gt; Dec.IsVirtualInstance(passedIn: unknown) → boolean This function checks if the passed in value is a Dec VirtualInstance  "},{"title":"GetVirtualInstanceType​","type":1,"pageTitle":"Dec","url":"/api/Dec#GetVirtualInstanceType","content":"&lt;/&gt; Dec.GetVirtualInstanceType(passedIn: VirtualInstance) → &quot;New&quot; | &quot;Clone&quot; | &quot;Premade&quot; This function returns the constructor type for VirtualInstance (&quot;New&quot;, &quot;Clone&quot;, or &quot;Premade&quot;). Errors if the passed in value is not a VirtualInstance.  "},{"title":"IsState​","type":1,"pageTitle":"Dec","url":"/api/Dec#IsState","content":"&lt;/&gt; Dec.IsState(passedIn: unknown) → boolean This function checks if the passed in value is a State observable object  "},{"title":"IsStateRecord​","type":1,"pageTitle":"Dec","url":"/api/Dec#IsStateRecord","content":"&lt;/&gt; Dec.IsStateRecord(passedIn: unknown) → boolean This function checks if the passed in value is a [StateRecord] observable object  "},{"title":"IsObservable​","type":1,"pageTitle":"Dec","url":"/api/Dec#IsObservable","content":"&lt;/&gt; Dec.IsObservable(passedIn: unknown) → boolean This function checks if the passed in value is an Observable.  "},{"title":"Alpha​","type":1,"pageTitle":"Dec","url":"/api/Dec#Alpha","content":"&lt;/&gt; Dec.Alpha( source: Observable&lt;number&gt;, sourceRangeMin: number, sourceRangeMax: number ) → Alpha Creates a new Alpha Observable object, which maps the current value of the source observable to the range [0, 1] based on sourceRangeMin and sourceRangeMax  "},{"title":"CustomObservable​","type":1,"pageTitle":"Dec","url":"/api/Dec#CustomObservable","content":"&lt;/&gt; Dec.CustomObservable( getCurrent: () → T, createUpdateStream: (notifyChange: () → ()) → (() → ()) ) → Observable&lt;T&gt;  warning Consider opting for other Dec constructs (like State) over custom observables. When writing custom Dec observables, Make sure to implement the getCurrent and createUpdateStream parameters correctly, as failing to do so may cause memory leaks or unresponsive UI. Creates a new Dec Observable object. Observables are used to hold, derive, or map state within a Dec application. The first parameter should be a function that always returns the current state of the observable whenever called. For example, to observe the value of workspace.CurrentCamera.ViewportSize: local function getCurrent() return workspace.CurrentCamera.ViewportSize end The second parameter is a callback which sets up any event handling required to notify whenever the current state changes, and returns a &quot;cleanup&quot; function to close the event handling. For example, to observe the value of workspace.CurrentCamera.ViewportSize: local function createUpdateStream(notifyChange: () -&gt; ()) -- Start tracking changes to ViewportSize, and -- forward these to the `notifyChange` callback local connection = workspace.CurrentCamera :GetPropertyChangedSignal(&quot;ViewportSize&quot;) :Connect(notifyChange) -- Return a function which closes the update stream, -- cleaning up our connection. return function() connection:Disconnect() end end createUpdateStream is automatically called by Dec the first time an observable is subscribed (or used by a mounted VirtualInstance), and its return function to close the update stream is automatically called when the Observable's last subscriber is unsubscribed and/or the last VirtualInstance utilizing it is unmounted. Putting it all together, we can create a custom observable which tracks the ViewportSize of the player's camera: local function getCurrent() return workspace.CurrentCamera.ViewportSize end local function createUpdateStream(notifyChange: () -&gt; ()) local connection = workspace.CurrentCamera :GetPropertyChangedSignal(&quot;ViewportSize&quot;) :Connect(notifyChange) -- closeUpdateStream: return function() connection:Disconnect() end end local playerViewportSize = Dec.CustomObservable( getCurrent, createUpdateStream ) print(playerViewportSize:Current()) -- Output: 1920, 1080 Custom observables may be useful for connecting third party libraries or other systems in your game's codebase to a Dec UI application.  "},{"title":"Spring​","type":1,"pageTitle":"Dec","url":"/api/Dec#Spring","content":"&lt;/&gt; Dec.Spring( target: Observable&lt;T&gt;, angularFrequency: number? ) → Observable&lt;T&gt; Creates an easing observable that simulates the behavior of a critically damped spring. The spring simulates in realtime until the target value is reached. caution Spring must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  "},{"title":"IntSpring​","type":1,"pageTitle":"Dec","url":"/api/Dec#IntSpring","content":"&lt;/&gt; Dec.IntSpring( target: Observable&lt;T&gt;, angularFrequency: number ) → Observable&lt;T&gt; Creates an easing observable that simulates the behavior of a critically damped spring, constrained to the Integer range. Rounds the current position towards the target value, which is useful for UI components like currency or ammo counters. caution Springs must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  "},{"title":"Stopwatch​","type":1,"pageTitle":"Dec","url":"/api/Dec#Stopwatch","content":"&lt;/&gt; Dec.Stopwatch(maxDuration: number?) → Stopwatch Creates a new Stopwatch Observable, which simulates in realtime while subscribed.  "},{"title":"Timer​","type":1,"pageTitle":"Dec","url":"/api/Dec#Timer","content":"&lt;/&gt; Dec.Timer(duration: number) → Timer Creates a new Timer Observable, which simulates in realtime while subscribed.  "},{"title":"State​","type":1,"pageTitle":"Dec","url":"/api/Dec#State","content":"&lt;/&gt; Dec.State(initialValue: T) → State&lt;T&gt; Creates a new State Observable object with the given initial value.  "},{"title":"Dict​","type":1,"pageTitle":"Dec","url":"/api/Dec#Dict","content":"&lt;/&gt; Dec.Dict(initialValue:: {[K]: V}) → Dict&lt;K,V&gt; Creates a new Dict state observable with the given initial value.  "},{"title":"AngleSpring​","type":1,"pageTitle":"Dec","url":"/api/Dec#AngleSpring","content":"&lt;/&gt; Dec.AngleSpring( target: Observable&lt;T&gt;, angularFrequency: number? ) → Observable&lt;T&gt; Creates an easing observable that simulates the behavior of a critically damped spring, wrapped around the range [-pi, pi]. The spring simulates in realtime until the target value is reached. caution AngleSpring must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime!  "},{"title":"Eased​","type":1,"pageTitle":"Dec","url":"/api/Dec#Eased","content":"&lt;/&gt; Dec.Eased( target: Observable&lt;T&gt;, info: TweenInfo ) → Observable&lt;T&gt; Creates an Observable that eases in realtime every time the input Observable changes its value, based on the TweenInfo provided. caution Eased must have at least one Subscriber (or be mounted on at least one VirtualInstance) to simulate in realtime! "},{"title":"Record","type":0,"sectionRef":"#","url":"/api/Record","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Record","url":"/api/Record#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"Record","url":"/api/Record#Set","content":"&lt;/&gt; Record:Set( key: string, value: any ) → () Sets the value at a specific key.  "},{"title":"Current​","type":1,"pageTitle":"Record","url":"/api/Record#Current","content":"&lt;/&gt; Record:Current(key: any?) → any | T Gets the current value at a specific key, or the current value of the whole record if no first argument is provided. caution Currently, the value returned by StateRecord:Current() with no first parameter is mutable! Modifying this value directly may cause unexpected behavior!  "},{"title":"Index​","type":1,"pageTitle":"Record","url":"/api/Record#Index","content":"&lt;/&gt; Record:Index(key: any) → State&lt;any&gt; Creates a new observable which observes only a specific key within the record. Changes in other keys will not affect subscribers to this indexed state. The returned observable is also a State object, and setting values in this state will set values in the original Record object. "},{"title":"Spring","type":0,"sectionRef":"#","url":"/api/Spring","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Spring","url":"/api/Spring#functions","content":" "},{"title":"ResetVelocity​","type":1,"pageTitle":"Spring","url":"/api/Spring#ResetVelocity","content":"&lt;/&gt; Spring:ResetVelocity() → () Sets the velocity of the spring to the zero (or the origin vector). Useful in conjunction with Spring:SetPosition  "},{"title":"CurrentTarget​","type":1,"pageTitle":"Spring","url":"/api/Spring#CurrentTarget","content":"&lt;/&gt; Spring:CurrentTarget() → () Gets the current value of the spring's target observable.  "},{"title":"SetPosition​","type":1,"pageTitle":"Spring","url":"/api/Spring#SetPosition","content":"&lt;/&gt; Spring:SetPosition() → () Moves the current position of the spring to a new value, keeping the current velocity intact. "},{"title":"Root","type":0,"sectionRef":"#","url":"/api/Root","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Root","url":"/api/Root#functions","content":" "},{"title":"Render​","type":1,"pageTitle":"Root","url":"/api/Root#Render","content":"&lt;/&gt; Root:Render(node: VirtualInstance) → ReconciledNode Reconciles a Virtual Instance into the root's Roblox Instance. After the call, the Virtual Instance is sealed and cannot be mutated. Instead, you should use Dec Observers to mutate the Instance after reconciliation. It returns the Reconciled Node.  "},{"title":"Unmount​","type":1,"pageTitle":"Root","url":"/api/Root#Unmount","content":"&lt;/&gt; Root:Unmount() → () Unmounts the Virtual Instance from the Root, causing it to be deleted from the DataModel.  "},{"title":"Destroy​","type":1,"pageTitle":"Root","url":"/api/Root#Destroy","content":"&lt;/&gt; Root:Destroy() → () Unmounts and destroys the Root and its underlying Roblox Instance. This function should be called before discarding a Root object to ensure memory is properly freed. "},{"title":"State","type":0,"sectionRef":"#","url":"/api/State","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"State","url":"/api/State#functions","content":" "},{"title":"Set​","type":1,"pageTitle":"State","url":"/api/State#Set","content":"&lt;/&gt; State:Set(value: T) → () Updates the state's current value. "},{"title":"Stopwatch","type":0,"sectionRef":"#","url":"/api/Stopwatch","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#functions","content":" "},{"title":"Start​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Start","content":"&lt;/&gt; Stopwatch:Start() → () Starts the Stopwatch Observable. The observable will update with new values every heartbeat in real-time until it is stopped.  "},{"title":"Stop​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Stop","content":"&lt;/&gt; Stopwatch:Stop() → () Stops the Stopwatch Observable, reseting the elapsed time.  "},{"title":"Pause​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Pause","content":"&lt;/&gt; Stopwatch:Pause() → () Pauses the Stopwatch Observable at its current elapsed time position.  "},{"title":"Pause​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Pause","content":"&lt;/&gt; Stopwatch:Pause() → () Sets the current elapsed time of the Stopwatch.  "},{"title":"CurvedAlpha​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#CurvedAlpha","content":"&lt;/&gt; Stopwatch:CurvedAlpha() → Alpha Creates a new Alpha Observable that interpolates between 0 and one using the given easing style and direction. Useful for creating non-linear animations.  "},{"title":"SliceAlpha​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#SliceAlpha","content":"&lt;/&gt; Stopwatch:SliceAlpha() → Alpha Creates a new Alpha Observable that starts at startTime (maps to 0) and ends at endTime (maps to 1). Useful for slicing up animation sequences into smaller slices.  "},{"title":"Alpha​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Alpha","content":"&lt;/&gt; Stopwatch:Alpha() → Alpha Derives an Alpha observable object that maps the elasped time from 0 (start) to 1 (finish)  "},{"title":"Lerp​","type":1,"pageTitle":"Stopwatch","url":"/api/Stopwatch#Lerp","content":"&lt;/&gt; Stopwatch:Lerp() → Observable&lt;T&gt; Creates an observable that outputs an interpolated value between the start value and end value based on the current elapsed time. "},{"title":"Timer","type":0,"sectionRef":"#","url":"/api/Timer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Timer","url":"/api/Timer#functions","content":" "},{"title":"Start​","type":1,"pageTitle":"Timer","url":"/api/Timer#Start","content":"&lt;/&gt; Timer:Start() → () Starts the Timer Observable. The observable will update with new values every heartbeat in real-time until it is stopped.  "},{"title":"Stop​","type":1,"pageTitle":"Timer","url":"/api/Timer#Stop","content":"&lt;/&gt; Timer:Stop() → () Stops the Timer Observable, reseting the remaining time.  "},{"title":"Pause​","type":1,"pageTitle":"Timer","url":"/api/Timer#Pause","content":"&lt;/&gt; Timer:Pause() → () Pauses the Timer Observable at its current remaining time position.  "},{"title":"Pause​","type":1,"pageTitle":"Timer","url":"/api/Timer#Pause","content":"&lt;/&gt; Timer:Pause() → () Sets the current remaining time of the Timer.  "},{"title":"CurvedAlpha​","type":1,"pageTitle":"Timer","url":"/api/Timer#CurvedAlpha","content":"&lt;/&gt; Timer:CurvedAlpha() → Alpha Creates a new Alpha Observable that interpolates between 0 and one using the given easing style and direction. Useful for creating non-linear animations.  "},{"title":"SliceAlpha​","type":1,"pageTitle":"Timer","url":"/api/Timer#SliceAlpha","content":"&lt;/&gt; Timer:SliceAlpha() → Alpha Creates a new Alpha Observable that starts at startTime (maps to 0) and ends at endTime (maps to 1). Useful for slicing up animation sequences into smaller slices.  "},{"title":"Alpha​","type":1,"pageTitle":"Timer","url":"/api/Timer#Alpha","content":"&lt;/&gt; Timer:Alpha() → Alpha Derives an Alpha observable object that maps the current remaining time from 0 (start) to 1 (finish)  "},{"title":"SetDuration​","type":1,"pageTitle":"Timer","url":"/api/Timer#SetDuration","content":"&lt;/&gt; Timer:SetDuration(duration: number) → () Sets the duration of the Timer.  "},{"title":"Lerp​","type":1,"pageTitle":"Timer","url":"/api/Timer#Lerp","content":"&lt;/&gt; Timer:Lerp() → Observable&lt;T&gt; Creates an observable that outputs an interpolated value between the start value and end value based on the current remaining time. "},{"title":"Alpha-Based Animations","type":0,"sectionRef":"#","url":"/docs/Chapter1/Alphas","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Alpha-Based Animations","url":"/docs/Chapter1/Alphas#section-outline","content":"Deriving Alpha from stopwatchLerping values from AlphaSplicing Alpha rangesCurving AlphasUsing TweenInfo to improve Stopwatch animations "},{"title":"Animating UI Components","type":0,"sectionRef":"#","url":"/docs/Chapter1/Animations","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Animating UI Components","url":"/docs/Chapter1/Animations#section-outline","content":"Stopwatches and TimersEasedValueSprings "},{"title":"Creating/Destroying Children","type":0,"sectionRef":"#","url":"/docs/Chapter1/ObservableChildren","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Creating/Destroying Children","url":"/docs/Chapter1/ObservableChildren#section-outline","content":"Writing subcomponentsMapping Observables to VirtualInstancesAvoiding Reconciles - Passing State into subcomponent props "},{"title":"VirtualInstance","type":0,"sectionRef":"#","url":"/api/VirtualInstance","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#functions","content":" "},{"title":"SetProperties​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#SetProperties","content":"&lt;/&gt; VirtualInstance:SetProperties(propertyMap: {[string]: CanBeObservable&lt;any&gt;}) → () Adds properties to be rendered on the instance when it is reconciled. Multiple calls to this function will merge the provided property map with the existing one, prioritizing the later call.  "},{"title":"SetAttributes​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#SetAttributes","content":"&lt;/&gt; VirtualInstance:SetAttributes(attributeMap: {[string]: CanBeObservable&lt;any&gt;}) → () Adds attributes to be rendered on the instance when it is reconciled. Multiple calls to this function will merge the provided attribute map with the existing one, prioritizing the latest calls.  "},{"title":"AddTags​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#AddTags","content":"&lt;/&gt; VirtualInstance:AddTags(tags: CanBeObservable&lt;{string}&gt;) → () Adds tags to the Virtual Instance when it is reconciled. Multiple calls to this function will add extra tags to the VirtualInstance if they do not exist.  "},{"title":"Connect​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#Connect","content":"&lt;/&gt; VirtualInstance:Connect( eventName: string, listener: (...any) → () ) → () Adds an event listener to the Virtual Instance, which will automatically be connected and disconnected as the VirtualInstance is reconciled.  "},{"title":"OutProperty​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutProperty","content":"&lt;/&gt; VirtualInstance:OutProperty( propName: string, initialValue: T ) → Observable&lt;T&gt; Creates an Observable object that updates to the current value of an property on the virtual instance once when it is mounted, and listens to updates on this property. Give initialValue a type annotation if initializing to nil (e.g. vInst:OutProperty(&quot;Adornee&quot;, nil :: Instance?)()  "},{"title":"OutInitialProperty​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutInitialProperty","content":"&lt;/&gt; VirtualInstance:OutInitialProperty( propName: string, initialValue: T ) → Observable&lt;T&gt;-AnobservablewiththesameoutputtypeasinitialValue. Creates an Observable object that updates to the original value of an property on the virtual instance once when it is mounted. This is useful for referencing properties on a premade instance without hardcoding them in a Dec component. Give initialValue a type annotation if initializing to nil (e.g. vInst:OutInitialProperty(&quot;Adornee&quot;, nil :: Instance?))  "},{"title":"OutAttribute​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutAttribute","content":"&lt;/&gt; VirtualInstance:OutAttribute( attributeName: string, initialValue: T ) → Observable&lt;T&gt; Creates an Observable object that updates to the current value of an attribute on the virtual instance once when it is mounted, and listens to updates on this attribute. Give initialValue a type annotation if initializing to nil (e.g. vInstance:OutAttribute(&quot;Foo&quot;, nil :: string?))  "},{"title":"OutInitialAttribute​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutInitialAttribute","content":"&lt;/&gt; VirtualInstance:OutInitialAttribute( attributeName: string, initialValue: T ) → Observable&lt;T&gt; Creates an Observable object that updates to the original value of an attribute on the virtual instance once when it is mounted. This is useful for referencing attributes on a premade instance without hardcoding them in a Dec component. Give initialValue a type annotation if initializing to nil (e.g. vInst:OutInitialAttribute(&quot;Foo&quot;, nil :: string?))  "},{"title":"OutInstance​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OutInstance","content":"&lt;/&gt; VirtualInstance:OutInstance() → Observable&lt;Instance? &gt; Outputs a reference to the reconciled instance to a Dec State object.  "},{"title":"Copy​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#Copy","content":"&lt;/&gt; VirtualInstance:Copy() → VirtualInstance Creates a shallow copy of the Virtual Instance.  "},{"title":"DeepCopy​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#DeepCopy","content":"&lt;/&gt; VirtualInstance:DeepCopy() → VirtualInstance Creates a deep copy of the VirtualInstance and all child VirtualInstances.  "},{"title":"AddChild​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#AddChild","content":"&lt;/&gt; VirtualInstance:AddChild( path: string | number | {string | number}, child: CanBeObservable&lt;Instance | VirtualInstance?&gt; ) → () Adds a child VirtualInstance node to this VirtualInstance. The path can be a dot-separated string, or an array of raw string names. If the child is an actual Instance, that instance will be reparanted to the virtual instance when reconciled, and destroyed when the VirtualInstances is unmounted. If the child is a VirtualInstance, it will be created or found depending on the type of VirtualInstance passed in.  "},{"title":"AddChildren​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#AddChildren","content":"&lt;/&gt; VirtualInstance:AddChildren(childMap: CanBeObservable&lt;{[any]: CanBeObservable&lt;VirtualInstance?&gt;}&gt;) → () Adds multiple children to the VirtualInstance given a child map. See VirtualInstance:Child() for API reference  "},{"title":"OnMount​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OnMount","content":"&lt;/&gt; VirtualInstance:OnMount(callback: (instance: Instance ) → ()) → () Adds a lifecycle callback to be called when the Virtual Instance is mounted.  "},{"title":"OnUnmount​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#OnUnmount","content":"&lt;/&gt; VirtualInstance:OnUnmount(callback: (instance: Instance ) → ()) → () Adds a lifecycle callback to be called when the Virtual Instance is unmounted.  "},{"title":"ExtractChildTemplate​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#ExtractChildTemplate","content":"&lt;/&gt; VirtualInstance:ExtractChildTemplate(nameOrPredicate: string | {string}) → VirtualInstance Specifies that when the VirtualInstance is mounted, returns a new VirtualInstance which automatically mounts on the first child matching the name (or predicate) defined in the first argument to this method. Upon mount, all other children matching this name will be destroyed, and the template will be parented to nil by defalt. On unmount, it will be reparented to its original location if possible. Usage example: local function CardListUI() -- Define a VirtualInstance to be mounted on pre-existing UI in PlayerGui local rootUI = Dec.Premade(&quot;ScreenGui&quot;) -- Index a ScrollingFrame containing template cards local cardList = rootUI:FindChild(&quot;ScrollingFrame&quot;, &quot;CardList&quot;) -- Extract the first template named &quot;CardTemplate&quot;, and destroy all other -- premade templates with that same name local cardTemplate = cardList:ExtractChildTemplate(&quot;CardTemplate&quot;) -- Generate 10 cards from the template local cards = {} for i = 1, 10 do table.insert(cards, Dec.Clone(cardTemplate, { LayoutOrder = i })) end return rootUI end   "},{"title":"FindChild​","type":1,"pageTitle":"VirtualInstance","url":"/api/VirtualInstance#FindChild","content":"&lt;/&gt; VirtualInstance:FindChild(childPath: string) → VirtualInstance Creates a new VirtualInstance that automatically mounts on the child of the parent VirtualInstance. Will wait until a child with the given name is found. The following blocks of code are equivalent: local parent = Dec.Premade(&quot;Frame&quot;) local child = Dec.Premade(&quot;Frame&quot;) parent:AddChild(&quot;ChildName&quot;, child) local parent = Dec.Premade(&quot;Frame&quot;) local child = parent:FindChild(&quot;ChildName&quot;)  "},{"title":"Passing in Props","type":0,"sectionRef":"#","url":"/docs/Chapter1/Props","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Passing in Props","url":"/docs/Chapter1/Props#section-outline","content":"Writing Re-usable componentsPassing Customization Values through PropsPassing State through PropsPassing Callbacks through PropsType Annotations for Props - Using the most of Dec's robust static analysis supportWhen in doubt, use any. Types should give you warning signs for API misuse, but not be somethign you should have to fight with "},{"title":"Using State","type":0,"sectionRef":"#","url":"/docs/Chapter1/State","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Using State","url":"/docs/Chapter1/State#section-outline","content":"What is State? (A type of Observable - we will go over in a later section, fundamental buidling block of UI)Breaking down States in a UIConsuming State in a VirtualInstance "},{"title":"Virtual Instances","type":0,"sectionRef":"#","url":"/docs/Chapter1/VirtualInstance","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Virtual Instances","url":"/docs/Chapter1/VirtualInstance#section-outline","content":"What is a Virtual Instance? (Declarative Programming - concerned with whatis more than the procedures of how exactly things work behind the scenes)What is a Component?Mounting you AppWhat can VirtualInstances do over real instances?What are the limitations of VirtualInstance?New, Premade, and Clone "},{"title":"More VirtualInstance Methods","type":0,"sectionRef":"#","url":"/docs/Chapter1/VirtualInstanceReprise","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"More VirtualInstance Methods","url":"/docs/Chapter1/VirtualInstanceReprise#section-outline","content":"MutabilityExtra VirtualInstance methods (Tags, Attributes, Connections)Multiplicity and Composition - A nice way to separate/organize concernsVirtualInstance Freezing Caveat - VirtualInstances are mutable, but cannot be changed after mount "},{"title":"Observables & Mapping State","type":0,"sectionRef":"#","url":"/docs/Chapter1/Observables","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Observables & Mapping State","url":"/docs/Chapter1/Observables#section-outline","content":"Deriving Values from State (Mapping observables)Single Source of truth - the golden rule of State managementDeriving Values from Multiple StatesNumeric Operator OverloadsSubscribing to Observables and States - Caveat "},{"title":"Writing Custom Observables","type":0,"sectionRef":"#","url":"/docs/Chapter2/CustomObservablues","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Writing Custom Observables","url":"/docs/Chapter2/CustomObservablues#section-outline","content":"Use cases - Interop with game systems and other librariesCore components (already have documentation in moonwave somewhat!)Rules and CaveatsGeneralizing "},{"title":"Event Handling","type":0,"sectionRef":"#","url":"/docs/Chapter2/Events","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Event Handling","url":"/docs/Chapter2/Events#section-outline","content":"Simple Event handlingComponent abstraction and Forwarding Callbacks through PropsUpdating Program State via Events "},{"title":"Adding Gamepad Support","type":0,"sectionRef":"#","url":"/docs/Chapter2/GamepadSupport","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Adding Gamepad Support","url":"/docs/Chapter2/GamepadSupport#section-outline","content":"Holy cow we need to add first-class support for Roblox's gamepad methods...Dec.GamepadSelect(vInstance)Dec.GamepadAddSelectionParent(name: string, vInstance)Dec.GamepadAddSelectionTuple(name: string, {vInstance})Dec.GamepadRemoveSelectionGroup(name: string, vInstance)Dec.GamepadVirtualCursorEnable(vInstance) Once these are implemented, document them and add a guide for using them and mapping these to Dec states with proper Unsubscribe handling! "},{"title":"Linked & Reusable Components","type":0,"sectionRef":"#","url":"/docs/Chapter2/Linking","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Linked & Reusable Components","url":"/docs/Chapter2/Linking#section-outline","content":"Separating Linked state into separate componetnsAdvantages / DisadvantagesRe-using Unlinked ComponentsRe-using Linked Components "},{"title":"Higher-Order Functions","type":0,"sectionRef":"#","url":"/docs/Chapter2/HOFs","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Higher-Order Functions","url":"/docs/Chapter2/HOFs#section-outline","content":"What are Higher-Order Functions?Re-useable ComponentsPassing a VirtualInstance as propsBenefits and Use CasesMethod 1: Chaining Dec ComponentsMethod 2: Composing Dec ComponentsThings to avoid "},{"title":"Record and Dict States","type":0,"sectionRef":"#","url":"/docs/Chapter2/StateRecords","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Record and Dict States","url":"/docs/Chapter2/StateRecords#section-outline","content":"State Records and DictionariesUse casesIndexing - Observing a key from a store of Dec States in O(1) time/space "},{"title":"Structuring your Application","type":0,"sectionRef":"#","url":"/docs/Chapter2/Scaling","content":"","keywords":""},{"title":"Section Outline:​","type":1,"pageTitle":"Structuring your Application","url":"/docs/Chapter2/Scaling#section-outline","content":"Passing Callbacks through PropsScoping out responsibility of Views - Separation of ConcernsNesting State ModulesNesting Type ModulesWrite source code in ReplicatedStorage over StarterPlayerScripts - Avoid WaitForChild for reused components "},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/Installation","content":"","keywords":""},{"title":"Roblox Studio Installation​","type":1,"pageTitle":"Installation","url":"/docs/Installation#roblox-studio-installation","content":"To add Dec to your Roblox Studio project, download thelatest .rbxmx release from Github, then drag the model file into Roblox Studio. Place the Dec library somewhere in ReplicatedStorage. "},{"title":"Rojo + Wally Installation​","type":1,"pageTitle":"Installation","url":"/docs/Installation#rojo--wally-installation","content":"To install Dec using Wally, first install Rojoand Wally, then search for the last published Dec release on the Wally website, or run the following command to get the latest version: $ wally search ambergracesoftware/dec  To add Dec to your project, add an entry under the [dependencies] section of your project's wally.toml file, replacing X.Y.Z with Dec's latest version number: Dec = &quot;ambergracesoftware/dec@X.Y.Z&quot;  Finally, run $ wally install  On the command line to get have the latest install added to your project's Packages folder. It is also recommended you run thewally-package-types tool after installing or updating Dec, as well as theLuau LSP in order to utilize Dec with Luau's type safety features. "},{"title":"Hello, World!","type":0,"sectionRef":"#","url":"/docs/HelloWorld","content":"Hello, World! Now that Dec is installed, let's try it out with a plussed-up rainbow &quot;Hello, World!&quot; UI in Roblox Studio! ***Your browser does not support HTML Videos.*** ***Please update your browser version and/or download [Google Chrome](https://www.google.com/chrome/) to view this page correctly.*** First, make sure the Dec package is properly installed and located in game.ReplicatedStorage.Packages.Dec Next, in Roblox Studio, create a LocalScript undergame.StarterPlayer.StarterPlayerScripts and paste the following: --!strict local Dec = require(game.ReplicatedStorage.Packages.Dec) local function App() local stopwatch = Dec.Stopwatch() stopwatch:Start() return Dec.New(&quot;ScreenGui&quot;, {}, { Label = Dec.New(&quot;TextLabel&quot;, { Size = UDim2.fromScale(1, 1), BackgroundTransparency = 1, TextSize = 24, TextColor3 = stopwatch:Map(function(currentTime) return Color3.fromHSV((currentTime / 5) % 1, 1, 1) end), Text = &quot;Hello, World!&quot;, }) }) end local root = Dec.Root(game.Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;)) root:Render(App()) The tutorial section will go over how each of Dec's features work together to help build beautiful and responsive UI components!","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":""},{"title":"Why Dec?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#why-dec","content":"Dec has many advantages over both standalone UI or other UI frameworks. Notably, it: Makes it easy to rapidly prototype UI and adjust code when requirements changeMakes it effortless to animate and write UI transitions to meet your visionMakes it easy to scale performant, complex menus and interactions to match a project's needsOffers a robust repository of open source utilities that lend themselves to well-understood code, with a detailed documentation to refer to at all times as the only onboarding cost for new developersOffers first class support both for using pre-designed templates in Roblox Studio, as well as writing components entirely in code depending on project preferences and needs. "}]