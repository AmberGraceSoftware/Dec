"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8110],{10329:e=>{e.exports=JSON.parse('{"functions":[{"name":"Current","desc":"Returns the current value of the Observable.","params":[],"returns":[{"desc":"","lua_type":"T"}],"function_type":"method","source":{"line":81,"path":"src/Observables/Observable.luau"}},{"name":"Map","desc":"Creates a new Observable that emits the values from the original Observable\\nmapped by the provided function.","params":[{"name":"mappingFunction","desc":"","lua_type":"(value: T) -> any"}],"returns":[{"desc":"","lua_type":"Observable<any>"}],"function_type":"method","source":{"line":98,"path":"src/Observables/Observable.luau"}},{"name":"Subscribe","desc":"Subscribes to changes in the Observable. Returns a function that, when\\ncalled, will unsubscribe the listener from the Observable\'s changes. If\\n`true` is provided as a second argument, will also call the listener once\\nimmediately with the current value of the Observable.\\n\\n:::caution\\nMake sure you handle the returned \\"Unsubscribe\\" function whenever a calling\\n`Subscribe`! If you forget to do this, you may encounter memory leaks!\\n\\nObservables will remain in memory until all listeners are unsubscribed, and\\nall VirtualInstances using it are unmounted\\n```lua\\n-- A new Observable can always be garbage collected if dereferenced\\nlocal coins = createCoinsObserver()\\n\\n-- However, once we subscribe to it, it will stick\\n-- around in memory until we call Unsubscribe!\\nlocal unsubscribe = coins:Subscribe(function(value)\\n    print(\\"Coins is\\", value)\\nend, true)\\ntask.wait(5)\\n\\n-- The \\"coins\\" observable can now be garbage collected\\nunsubscribe() \\n```\\n:::","params":[{"name":"listener","desc":"","lua_type":"(value: T) -> ()"},{"name":"immediatelyCallListener","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"() -> ()"}],"function_type":"method","source":{"line":142,"path":"src/Observables/Observable.luau"}},{"name":"Destroy","desc":"Destroys the Observable, releasing all its resources and unsubscribing all\\nlisteners. All further [Observable:Subscribe] calls will error.","params":[],"returns":[],"function_type":"method","source":{"line":177,"path":"src/Observables/Observable.luau"}}],"properties":[],"types":[],"name":"Observable","desc":"Observables are objects that resolve to some value, and can be subscribed to\\ndetect updates whenver this value changes.\\n\\nWhen setting a [VirtualInstance]\'s properties to an Observable, the\\nproperties in the mounted instance will automatically be updated by Dec to\\nmatch the current value of the observable whenever its value changes.\\n\\nAn observable will automatically be garbage collected so long as there are\\nno listeners are currently subscribed to it, and it is not currently being\\nused by a mounted VirtualInstance.\\n\\n*(Constructed via [Dec.CustomObservable])*","source":{"line":25,"path":"src/Observables/Observable.luau"}}')}}]);